'use client'

import { create } from 'zustand'
import { persist } from 'zustand/middleware'
import type { GLMChatState, ChatMessage, ChatSession, ChatMessageInput } from '@/types/chat'
import { ChatSession as DatabaseChatSession, ChatMessage as DatabaseChatMessage } from '@/types/database'
import { useAuth } from './useAuth'

interface EnhancedGLMChatState extends GLMChatState {
  error: string | null
  isSyncing: boolean
  lastSyncTime: Date | null

  // 云端同步操作
  fetchSessions: () => Promise<void>
  syncSessions: () => Promise<void>
  fetchSessionMessages: (sessionId: string) => Promise<void>

  // 重写的方法以支持云端同步
  createNewSession: () => Promise<string>
  addMessage: (sessionId: string, message: ChatMessageInput) => Promise<string>
  deleteSession: (sessionId: string) => Promise<void>

  clearError: () => void
}

// export const useGLMChat = create<EnhancedGLMChatState>()(
//   persist(
//     (set, get) => ({
  persist(
    (set, get) => ({
      sessions: [],
      currentSessionId: null,
      isLoading: false,
      apiKey: '',
      currentMessage: '',
      error: null,
      isSyncing: false,
      lastSyncTime: null,

      // 云端同步操作
      fetchSessions: async () => {
        const auth = useAuth.getState()
        if (!auth.session) {
          set({ error: '用户未登录' })
          return
        }

        set({ isLoading: true, error: null })

        try {
          const response = await fetch('/api/chat/sessions', {
            headers: {
              'Authorization': `Bearer ${auth.session.access_token}`,
            },
          })

          if (!response.ok) {
            const error = await response.text()
            throw new Error(error)
          }

          const dbSessions: DatabaseChatSession[] = await response.json()

          // 转换数据库格式到前端格式
          const frontendSessions: ChatSession[] = dbSessions.map(session => ({
            id: session.id,
            title: session.title,
            messages: [], // 消息需要单独获取
            createdAt: new Date(session.created_at),
            updatedAt: new Date(session.updated_at),
          }))

          set({
            sessions: frontendSessions,
            lastSyncTime: new Date()
          })
        } catch (error) {
          console.error('获取聊天会话失败:', error)
          set({ error: '获取聊天会话失败' })
        } finally {
          set({ isLoading: false })
        }
      },

      syncSessions: async () => {
        set({ isSyncing: true, error: null })
        await get().fetchSessions()
        set({ isSyncing: false })
      },

      fetchSessionMessages: async (sessionId: string) => {
        const auth = useAuth.getState()
        if (!auth.session) {
          set({ error: '用户未登录' })
          return
        }

        try {
          const response = await fetch(`/api/chat/sessions/${sessionId}/messages`, {
            headers: {
              'Authorization': `Bearer ${auth.session.access_token}`,
            },
          })

          if (!response.ok) {
            const error = await response.text()
            throw new Error(error)
          }

          const dbMessages: DatabaseChatMessage[] = await response.json()

          // 转换数据库格式到前端格式
          const frontendMessages: ChatMessage[] = dbMessages.map(message => ({
            id: message.id,
            role: message.role as any,
            content: message.content,
            timestamp: new Date(message.created_at),
          }))

          set((state) => ({
            sessions: state.sessions.map((session) =>
              session.id === sessionId
                ? { ...session, messages: frontendMessages }
                : session
            ),
          }))
        } catch (error) {
          console.error('获取聊天消息失败:', error)
          set({ error: '获取聊天消息失败' })
        }
      },

      setCurrentSessionId: (id) => set({ currentSessionId: id }),

      createNewSession: async () => {
        const auth = useAuth.getState()
        if (!auth.session) {
          set({ error: '用户未登录' })
          return ''
        }

        set({ error: null })

        try {
          const response = await fetch('/api/chat/sessions', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${auth.session.access_token}`,
            },
            body: JSON.stringify({ title: '新对话' }),
          })

          if (!response.ok) {
            const error = await response.text()
            throw new Error(error)
          }

          const newSession: DatabaseChatSession = await response.json()

          // 转换为前端格式
          const frontendSession: ChatSession = {
            id: newSession.id,
            title: newSession.title,
            messages: [],
            createdAt: new Date(newSession.created_at),
            updatedAt: new Date(newSession.updated_at),
          }

          set((state) => ({
            sessions: [frontendSession, ...state.sessions],
            currentSessionId: newSession.id,
          }))

          return newSession.id
        } catch (error) {
          console.error('创建聊天会话失败:', error)
          set({ error: '创建聊天会话失败' })
          return ''
        }
      },

      addMessage: async (sessionId: string, message: ChatMessageInput): Promise<string> => {
        const auth = useAuth.getState()
        if (!auth.session) {
          set({ error: '用户未登录' })
          return ''
        }

        set({ error: null })

        try {
          const response = await fetch(`/api/chat/sessions/${sessionId}/messages`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${auth.session.access_token}`,
            },
            body: JSON.stringify({
              role: message.role,
              content: message.content,
            }),
          })

          if (!response.ok) {
            const error = await response.text()
            throw new Error(error)
          }

          const newMessage: DatabaseChatMessage = await response.json()

          // 转换为前端格式
          const frontendMessage: ChatMessage = {
            id: newMessage.id,
            role: newMessage.role as any,
            content: newMessage.content,
            timestamp: new Date(newMessage.created_at),
          }

          set((state) => {
            const sessions = state.sessions.map((session) => {
              if (session.id === sessionId) {
                const updatedMessages = [...session.messages, frontendMessage]
                let title = session.title

                // 如果是第一条用户消息，更新会话标题
                if (message.role === 'user' && session.messages.length === 0) {
                  title = message.content.slice(0, 30) + (message.content.length > 30 ? '...' : '')
                }

                return {
                  ...session,
                  messages: updatedMessages,
                  title,
                  updatedAt: new Date(),
                }
              }
              return session
            })

            return { sessions }
          })

          return newMessage.id
        } catch (error) {
          console.error('添加聊天消息失败:', error)
          set({ error: '添加聊天消息失败' })
          return ''
        }
      },

      updateMessage: (sessionId, messageId, content) => {
        set((state) => ({
          sessions: state.sessions.map((session) => {
            if (session.id === sessionId) {
              return {
                ...session,
                messages: session.messages.map((message) => {
                  if (message.id === messageId) {
                    return { ...message, content }
                  }
                  return message
                }),
                updatedAt: new Date(),
              }
            }
            return session
          }),
        }))
      },

      deleteMessage: (sessionId, messageId) => {
        set((state) => ({
          sessions: state.sessions.map((session) => {
            if (session.id === sessionId) {
              return {
                ...session,
                messages: session.messages.filter((message) => message.id !== messageId),
                updatedAt: new Date(),
              }
            }
            return session
          }),
        }))
      },

      deleteSession: async (sessionId: string) => {
        const auth = useAuth.getState()
        if (!auth.session) {
          set({ error: '用户未登录' })
          return
        }

        set({ error: null })

        try {
          const response = await fetch(`/api/chat/sessions/${sessionId}`, {
            method: 'DELETE',
            headers: {
              'Authorization': `Bearer ${auth.session.access_token}`,
            },
          })

          if (!response.ok) {
            const error = await response.text()
            throw new Error(error)
          }

          set((state) => {
            const newSessions = state.sessions.filter((session) => session.id !== sessionId)
            const newCurrentSessionId = state.currentSessionId === sessionId
              ? (newSessions.length > 0 ? newSessions[0].id : null)
              : state.currentSessionId

            return {
              sessions: newSessions,
              currentSessionId: newCurrentSessionId,
            }
          })
        } catch (error) {
          console.error('删除聊天会话失败:', error)
          set({ error: '删除聊天会话失败' })
        }
      },

      updateSessionTitle: (sessionId, title) => {
        set((state) => ({
          sessions: state.sessions.map((session) => {
            if (session.id === sessionId) {
              return { ...session, title, updatedAt: new Date() }
            }
            return session
          }),
        }))
      },

      setCurrentMessage: (message) => set({ currentMessage: message }),

      setIsLoading: (loading) => set({ isLoading: loading }),

      setApiKey: (key) => set({ apiKey: key }),

      getSession: (sessionId) => {
        return get().sessions.find((session) => session.id === sessionId)
      },

      getCurrentSession: () => {
        const { currentSessionId, sessions } = get()
        if (!currentSessionId) return undefined
        return sessions.find((session) => session.id === currentSessionId)
      },

      clearError: () => set({ error: null }),
    }),
    {
      name: 'glm-chat-storage',
      partialize: (state) => ({
        sessions: state.sessions,
        currentSessionId: state.currentSessionId,
        apiKey: state.apiKey,
      }),
    }
  )
)
